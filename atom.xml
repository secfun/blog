<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[secfun]]></title>
  <link href="http://blog.esile.me/atom.xml" rel="self"/>
  <link href="http://blog.esile.me/"/>
  <updated>2016-11-22T14:01:34+08:00</updated>
  <id>http://blog.esile.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[px em rem]]></title>
    <link href="http://blog.esile.me/14799727855223.html"/>
    <updated>2016-11-24T15:33:05+08:00</updated>
    <id>http://blog.esile.me/14799727855223.html</id>
    <content type="html"><![CDATA[
<p>项目中px，em，rem都可以表示尺寸，它们有何区别？</p>

<ul>
<li>em表示像对于父元素字体的大小的倍数，比如父元素font-size是10px，子元素大小是1.5em, 那么子元素的大小就是15px。</li>
<li>rem表示相对于根元素(html)字体大小的倍数。</li>
<li><p>注意事项：</p>

<ul>
<li><p>浏览器默认的字体大小是16px，浏览器的默认字体高都是 16px，未经调整的浏览器显示 1em = 16px。但是有一个问题，如果设置 1.2em 则变成 19.2px，问题是 px 表示大小时数值会忽略掉小数位的（你想像不出来半个像素吧）。而且 1em = 16px 的关系不好转换，因此，常常人为地使 1em = 10px。这里要借助字体的 % 来作为桥梁。</p></li>
<li><p>因为默认时字体 16px = 100%，则有 10px = 62.5%。所以首先在 body 中全局声明 font-size=62.5%=10px，也就是定义了网页 body 默认字体大小为 10px，由于 em 有继承父级元素字体大小的特性，如果某元素的父级没有设定字体大小，那么它就继续了 body 默认字体大小 1em = 10px。</p></li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AMQP协议]]></title>
    <link href="http://blog.esile.me/14793659525228.html"/>
    <updated>2016-11-17T14:59:12+08:00</updated>
    <id>http://blog.esile.me/14793659525228.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用命令备忘]]></title>
    <link href="http://blog.esile.me/14793567225986.html"/>
    <updated>2016-11-17T12:25:22+08:00</updated>
    <id>http://blog.esile.me/14793567225986.html</id>
    <content type="html"><![CDATA[
<ul>
<li>rsync 非默认端口连接
<code>rsync -avz -e &quot;ssh -p 10086&quot; user@host:/path/to/file</code></li>
<li>ssh 登录调试
<code>ssh -vT user@host</code></li>
<li>生成rsa key
<code>ssh-keygen -t rsa -C comment</code></li>
<li>pip change repo
<code>pip install xxx -i</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python import]]></title>
    <link href="http://blog.esile.me/14791926847943.html"/>
    <updated>2016-11-15T14:51:24+08:00</updated>
    <id>http://blog.esile.me/14791926847943.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">准备知识</h2>

<ul>
<li><p>module in python</p>

<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py appended. Within a module, the module’s name (as a string) is available as the value of the global variable <strong>name</strong>.</p>

<p>They are executed only the first time the module name is encountered in an import statement. </p>

<p>module can be excuted as script by -m switch</p></li>
<li><p>dir()</p>

<p>Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.</p></li>
<li><p>sys.modules</p>

<p>存储着已经加载的module</p></li>
<li><p>sys.path</p>

<p>module的搜索路径， 第一个为空，表示是当前运行python文件的文件夹。</p></li>
<li><p>sys.meta_path</p>

<p>A list of finder objects that have their find_module() methods called to see if one of the objects can find the module to be imported. The find_module() method is called at least with the absolute name of the module being imported. If the module to be imported is contained in package then the parent package’s <strong>path</strong> attribute is passed in as a second argument. The method returns None if the module cannot be found, else returns a loader.</p>

<p>sys.meta_path is searched before any implicit default finders or sys.path.`</p></li>
<li><p>package<br/>
    package is a collection of module<br/>
    from package import item, the item can be either a submodule (or subpackage) of the package<br/>
    from xx import subpackage/module/object<br/>
    import subpackage/module</p></li>
<li><p>-m的作用</p>

<p>指定运行脚本的package和name<br/>
python a.py a的__name__属性为__main__<br/>
python -m some_dir.a a的__package__为some_dir <strong>name</strong>为a</p></li>
<li><p>__package__</p>

<p>解决相对引用下包定位的问题</p>

<pre><code>ex1/
    foo.py
    main.py
</code></pre>

<pre><code class="language-python">foo.py
a=10
</code></pre>

<pre><code class="language-main.py">from . import foo
</code></pre>

<p>如果直接在ex1下执行： python main.py 会报<code>ValueError: Attempted relative import in non-package</code>, 原因是main的__package__为空<br/>
但是可以通过 python -m ex1.main来解决</p></li>
<li><p>__name__</p>

<p>当前module的name</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[celery]]></title>
    <link href="http://blog.esile.me/14791909799046.html"/>
    <updated>2016-11-15T14:22:59+08:00</updated>
    <id>http://blog.esile.me/14791909799046.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux中的多线程]]></title>
    <link href="http://blog.esile.me/14791359815853.html"/>
    <updated>2016-11-14T23:06:21+08:00</updated>
    <id>http://blog.esile.me/14791359815853.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">相关API</h2>

<p>Linux对线程的操作封装在pthread.h这个头文件中。</p>

<h4 id="toc_1">创建</h4>

<pre><code class="language-c">pthread_t pthread_t1, pthread_t2;
pthread_create(&amp;pthread_t1, NULL, (void *) produce, NULL);
</code></pre>

<h4 id="toc_2">join</h4>

<p>You can wait for a thread to finish by calling its join() method. For instance, in the following code, the current thread will wait until thread2 finishes before printing Done.</p>

<pre><code class="language-c">thread2.start();
// do more stuff here
thread2.join();
System.out.println(&quot;Done&quot;);
</code></pre>

<h2 id="toc_3">线程同步</h2>

<h4 id="toc_4">race condition</h4>

<pre><code class="language-c">//
// Created by xdy on 16/11/23.
//
#include &quot;stdio.h&quot;
#include &quot;pthread.h&quot;
#include &quot;time.h&quot;

int shared_int;

void increase(void) {
    printf(&quot;current thread id: %d,init shared_int: %d\n&quot;,pthread_self(), shared_int);
    printf(&quot;current thread id: %d,start shared_int: %d\n&quot;,pthread_self(), shared_int);
    for (int i = 0; i &lt; 100000; ++i) {
        shared_int += 1;
    }
    printf(&quot;end shared_int: %d\n&quot;, shared_int);
}

int main() {
    pthread_t pthread_t1, pthread_t2, pthread_t3;
    pthread_create(&amp;pthread_t1, NULL, (void *) increase, NULL);
    pthread_create(&amp;pthread_t2, NULL, (void *) increase, NULL);
    pthread_create(&amp;pthread_t3, NULL, (void *) increase, NULL);

    pthread_join(pthread_t1, NULL);
    pthread_join(pthread_t2, NULL);
    pthread_join(pthread_t3, NULL);
    printf(&quot;shared_int: %d&quot;, shared_int);
    return 0;
}
</code></pre>

<p>输出</p>

<pre><code class="language-c">/Users/xdy/Library/Caches/CLion2016.1/cmake/generated/algo-6e4e421/6e4e421/Debug0/algo
current thread id: 528384,init shared_int: 0
current thread id: 1064960,init shared_int: 0
current thread id: 1601536,init shared_int: 0
current thread id: 528384,start shared_int: 0
current thread id: 1064960,start shared_int: 0
current thread id: 1601536,start shared_int: 0
end shared_int: 100025
end shared_int: 115999
end shared_int: 140708
shared_int: 140708
Process finished with exit code 0
</code></pre>

<p>上边三个线程产生了race condition, 导致最后的结果不可预测。</p>

<h4 id="toc_5">mutex</h4>

<pre><code class="language-c">//
// Created by xdy on 16/11/23.
//
#include &quot;stdio.h&quot;
#include &quot;pthread.h&quot;
#include &quot;time.h&quot;

int shared_int;
pthread_mutex_t mutex_t;


void increase(void) {
    printf(&quot;current thread id: %d,init shared_int: %d\n&quot;,pthread_self(), shared_int);
    pthread_mutex_lock(&amp;mutex_t);
    printf(&quot;current thread id: %d,start shared_int: %d\n&quot;,pthread_self(), shared_int);
    for (int i = 0; i &lt; 100000; ++i) {
        shared_int += 1;
    }
    printf(&quot;end shared_int: %d\n&quot;, shared_int);
    pthread_mutex_unlock(&amp;mutex_t);
}

int main() {
    pthread_mutex_init(&amp;mutex_t, NULL);
    pthread_t pthread_t1, pthread_t2, pthread_t3;
    pthread_create(&amp;pthread_t1, NULL, (void *) increase, NULL);
    pthread_create(&amp;pthread_t2, NULL, (void *) increase, NULL);
    pthread_create(&amp;pthread_t3, NULL, (void *) increase, NULL);

    pthread_join(pthread_t1, NULL);
    pthread_join(pthread_t2, NULL);
    pthread_join(pthread_t3, NULL);
    printf(&quot;shared_int: %d&quot;, shared_int);
    return 0;
}
</code></pre>

<p>输出</p>

<pre><code>/Users/xdy/Library/Caches/CLion2016.1/cmake/generated/algo-6e4e421/6e4e421/Debug0/algo
current thread id: 528384,init shared_int: 0
current thread id: 1064960,init shared_int: 0
current thread id: 1601536,init shared_int: 0
current thread id: 528384,start shared_int: 0
end shared_int: 100000
current thread id: 1064960,start shared_int: 100000
end shared_int: 200000
current thread id: 1601536,start shared_int: 200000
end shared_int: 300000
shared_int: 300000
Process finished with exit code 0
</code></pre>

<p>通过结果可以看出来线程的内部的代码可以被&quot;原子性&quot;的执行,最后的结果也变成了预期的300000.</p>

<p>另外还有两个函数:</p>

<h6 id="toc_6"><code>int pthread_mutex_trylock(pthread_mutex_t *);</code></h6>

<p>这个函数在加锁失败时不会会让线程进入睡眠状态，它直接失败返回，所以需要自己判断返回值。</p>

<h6 id="toc_7"><code>int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,const struct timespec *restrict tsptr);</code></h6>

<p>使用这个函数可以指定一个超时时间，在这个超时时间到来之前如果没有获得锁，则失败返回，不会一直阻塞.注意这个时间不是时间段,而是一个阻塞到时间点的时间戳.</p>

<h6 id="toc_8">释放资源</h6>

<p><code>pthread_mutex_destroy(pthread_mutex_t *mutex);</code><br/>
如果在初始化互斥量的时候，分配了其它资源，需要使用上面这个函数来释放掉这些资源。这个函数执行之后，互斥量变成了未初始化的状态，对它执行操作的结果是未定义的。如果需要再次使用这个互斥量的话，可以再次执行初始化函数来初始化。</p>

<h4 id="toc_9">condition variable</h4>

<pre><code class="language-c">//
// Created by xdy on 16/11/23.
//
#include &quot;stdio.h&quot;
#include &quot;pthread.h&quot;
#include &lt;unistd.h&gt;

pthread_cond_t cond_t = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex_t;

void emit(void) {
    // sleep 3s
    for (int i = 0; i &lt; 3; ++i) {
        printf(&quot;sleep %d s\n&quot;, i);
        sleep(1);
    }
    pthread_mutex_lock(&amp;mutex_t);
    pthread_cond_signal(&amp;cond_t);
    puts(&quot;emmit&quot;);
    pthread_mutex_unlock(&amp;mutex_t);
}

void wait_signal(void) {
    pthread_cond_wait(&amp;cond_t, &amp;mutex_t);
    puts(&quot;emmited&quot;);
}

int main() {
    pthread_t emit_t, wait_signal_t;
    pthread_mutex_init(&amp;mutex_t, NULL);

    pthread_create(&amp;emit_t, NULL, (void *) emit, NULL);
    pthread_create(&amp;wait_signal_t, NULL, (void *) wait_signal, NULL);

    pthread_join(emit_t, NULL);
    pthread_join(wait_signal_t, NULL);

    return 0;
}
</code></pre>

<p>输出<br/>
```<br/>
/Users/xdy/Library/Caches/CLion2016.1/cmake/generated/algo-6e4e421/6e4e421/Debug0/algo<br/>
sleep 0 s<br/>
sleep 1 s<br/>
sleep 2 s<br/>
emmit<br/>
emmited</p>

<p>Process finished with exit code 0<br/>
```<br/>
wait_emit直到emit触发过后才执行,线程的执行顺序和我们预测的一样。一定要注意emit时候有cond在wait状态，否则emit不会产生效果。</p>

<h4 id="toc_10">信号量</h4>

<p><img src="media/14791359815853/14799857660065.jpg" alt=""/></p>

<blockquote>
<p>P原语表示试图进入使用资源，V原语表示添加生产资源。<br/>
P，V名称的来历：Dijkstra, one of the inventors of semaphores, used P and V. The letters come from the Dutch words Probeer (try) and Verhoog (increment).</p>
</blockquote>

<pre><code class="language-c">//
// Created by xdy on 16/11/24.
//

#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;


sem_t sem_t1;

char *get_time() {
    time_t rawtime;
    struct tm *timeinfo;

    time(&amp;rawtime);
    timeinfo = localtime(&amp;rawtime);
    char *now = asctime(timeinfo);
    return now;
}

void produce(void) {
    while (1) {
        sleep(1);
        sem_post(&amp;sem_t1);
        printf(&quot;thread produce at %s\n&quot;, get_time());
    }
}

void consume(void) {
    while (1) {
        sleep(3);
        sem_wait(&amp;sem_t1);
        printf(&quot;thread consume at %s\n&quot;, get_time());
    }
}

int main() {
    puts(&quot;semaphore&quot;);
    sem_init(&amp;sem_t1, 0, 0);
    pthread_t pthread_t1, pthread_t2;
    pthread_create(&amp;pthread_t1, NULL, (void *) produce, NULL);
    pthread_create(&amp;pthread_t2, NULL, (void *) consume, NULL);

    pthread_join(pthread_t1, NULL);
    pthread_join(pthread_t2, NULL);
}
</code></pre>

<pre><code>xudy@iZ286wee5zoZ ~/tmp&gt; ./sem
semaphore
thread produce at Fri Nov 25 00:05:50 2016

thread produce at Fri Nov 25 00:05:51 2016

thread consume at Fri Nov 25 00:05:52 2016

thread produce at Fri Nov 25 00:05:52 2016

thread produce at Fri Nov 25 00:05:53 2016

thread produce at Fri Nov 25 00:05:54 2016

thread consume at Fri Nov 25 00:05:55 2016
</code></pre>

<p>上边是在我电脑上的运行结果, sem_post 其实是一个P操作, 可以让sem_t1加1.<br/>
sem_wait调用时候根据当前sem_t1的值不同有两种变现:<br/>
      当sem_t1&gt;0时候, 直接sem_t1 -= 1, 然后接着向下执行;<br/>
      当sem_t1&lt;=0时候, 阻塞当前线程, 直到sem_t1的值大于0, 然后开始执行.<br/>
todo:// 当两个线程分别被阻塞时候, 是不是先被阻塞的那个先执行? 还是两个进入race condition?</p>

<p>ref:<br/>
<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html#SCHEDULING">http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html#SCHEDULING</a><br/>
<a href="http://stackoverflow.com/a/14925150/6877366">http://stackoverflow.com/a/14925150/6877366</a><br/>
<a href="http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html">http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[void *]]></title>
    <link href="http://blog.esile.me/14791190693458.html"/>
    <updated>2016-11-14T18:24:29+08:00</updated>
    <id>http://blog.esile.me/14791190693458.html</id>
    <content type="html"><![CDATA[
<p>A pointer to void is a &quot;generic&quot; pointer type. A void * can be converted to any other pointer type without an explicit cast. You cannot dereference a void * or do pointer arithmetic with it; you must convert it to a pointer to an complete data type first.</p>

<p>It gets used in places where you need to be able to work with different pointer types in the same code. One commonly cited example is the library function qsort:</p>

<pre><code class="language-c">void qsort(void *base, size_t nmemb, size_t size, 
           int (*compar)(const void *, const void *));
</code></pre>

<p>base is the address of an array, nmemb is the number of elements in the array, size is the size of each element, and compar is a pointer to a function that compares two elements of the array. It gets called like so:</p>

<pre><code class="language-c">int iArr[10];
double dArr[30];
long lArr[50];
...
qsort(iArr, sizeof iArr/sizeof iArr[0], sizeof iArr[0], compareInt);
qsort(dArr, sizeof dArr/sizeof dArr[0], sizeof dArr[0], compareDouble);
qsort(lArr, sizeof lArr/sizeof lArr[0], sizeof lArr[0], compareLong);
</code></pre>

<p>The array expressions iArr, dArr, and lArr are implicitly converted from array types to pointer types in the function call, and each is implicitly converted from &quot;pointer to int/double/long&quot; to &quot;pointer to void&quot;.</p>

<p>The comparison functions would look something like:</p>

<pre><code class="language-c">int compareInt(const void *lhs, const void *rhs)
{
  const int *x = lhs;  // convert void * to int * by assignment
  const int *y = rhs;

  if (*x &gt; *y) return 1;
  if (*x == *y) return 0;
  return -1;
}
</code></pre>

<p>By accepting void *, qsort can work with arrays of any type.</p>

<p>The disadvantage of using void * is that you throw type safety out the window and into oncoming traffic. There&#39;s nothing to protect you from using the wrong comparison routine:</p>

<p><code>qsort(dArr, sizeof dArr/sizeof dArr[0], sizeof dArr[0], compareInt);</code><br/>
compareInt is expecting its arguments to be pointing to ints, but is actually working with doubles. There&#39;s no way to catch this problem at compile time; you&#39;ll just wind up with a mis-sorted array.</p>

<h4 id="toc_0">void * and const void * in c</h4>

<p>A const void * points to memory that should not be modified.</p>

<p>A void * (non-const) points to memory that could be modified (but not via the void *; you&#39;d have to cast it first).</p>

<p>When you use memmove(), the source address is cast to const void *:</p>

<p>void *memmove(void *dst, const void *src, size_t nbytes);<br/>
That is an illustration when a void pointer can be cast to a constant void pointer. Basically, you can do it (convert to constant) at any time when you know you are not going to modify the memory that the pointer points at. This applies to any pointer - not just void pointers.</p>

<p>Converting the other way (from a constant pointer to a non-constant pointer) is a much more dangerous exercise. There&#39;s no guarantee that the memory pointed at actually is modifiable; for example, a string literal can be stored in readonly (constant) memory, and if you lose the const-ness with a cast and try to modify the string, you will likely get a segmentation fault or its equivalent - your program will stop suddenly and not under your control. This is not a good thing. So, do not change pointers from constant to non-constant without being very sure it is actually OK to lie to your compiler. Be aware that compilers do not like being lied to and can get their own back, usually at the most inconvenient moment (such as when demonstrating your program to an important prospective client in front of your boss, your boss&#39;s boss, and your boss&#39;s boss&#39;s boss).</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用docker来持续集成]]></title>
    <link href="http://blog.esile.me/14773745036118.html"/>
    <updated>2016-10-25T13:48:23+08:00</updated>
    <id>http://blog.esile.me/14773745036118.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post中的content-type]]></title>
    <link href="http://blog.esile.me/14721979511946.html"/>
    <updated>2016-08-26T15:52:31+08:00</updated>
    <id>http://blog.esile.me/14721979511946.html</id>
    <content type="html"><![CDATA[
<p>http的post协议可以把提交的内容放在http request body中，数据格式常见的有以下几种，针对不同的数据格式，服务端需要不同的解码方式。</p>

<ul>
<li><p>application/x-www-form-urlencoded</p></li>
<li><p>multipart/form-data</p></li>
<li><p>application/json</p></li>
<li><p>text/xml</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
